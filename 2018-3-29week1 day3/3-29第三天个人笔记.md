# 第三天
### FOR 循环
> 作用:按照一定的规律重复去做某件事情,此事我们就要使用循环处理了

// for循环体中,经常出现两个常用关键字;
1.continue: 继续  =>结束本轮循环(循环体中continue后面代码不在执行),继续执行下一轮循环
2.break: 中断或结束 => 强制结束整个循环,不做任何处理

```JavaScript
 var i=[12,23,34]
 // => 获取数组中的每一项(数组长度不固定)
for (var i = 1; i<= 10; i +=2){
    if (i<=5)
}

```

### 实战案例
操作DOM
> 在JS中通过一系列属性和方法,可以操作页面中的元素标签
>
>先操作谁先获取谁
>按照自己需求,使用对应的API(提供属性和方法)操作即可

[获取页面中的DOM元素]
document.getElementById
> 在整个文档中通过ID元素的属性值,获取到这个元素对象
> getElementById是获取元素的方法,而document限定了获取元素的范围,我们把这个范围称之为"上下文 [context]"

```JavaScript
var oBox = document.getElementById('box')
console.dir(oBox)

1,通过getElementById获取的元素是一个对象数据类型的值(里面包含很多内置属性)
typeof oBox  =>"object"

2,分析包含的属性
className:存储的是一个字符串,代表当前元素的样式类名

id：存储得是当前元素ID值(字符串)


innerHTML:存储当前元素中所有的内容(包含HTML标签)//=>获取元素里的内容识别文本和标签
innerText:存储当前元素中所有文本内容,(没有标签) // 不会识别标签



 onclick: 元素的一个事件属性,基于这个属性,可以给当前元素绑定点击事件
 onmouseover: 鼠标划过事件
 onmouseout: 鼠标离开事件

style:存储当前元素所有的**行内样式**值(获取和操作的都只能是写在标签上的样式,写在样式表中的样式,无法基于这个属性获取到)


```                     
                       通过  标签名字      
9 [context].getElementsByTagName
> 在指定上下文中,通过元素的标签名获取一组元素集合(一个元素集合HTMLCollection)
>
>上下文是我们自己来指定的

```Javascript
var boxList = oBox.getElementsByTagName('li')

1.获取的结果是一个元素集合(HTMLCollection),首先他也是 对象数据类型的,结构和数组非常相似(数字作为索引,从零开始递增,length代表长度),但他不是数组,我们叫他类数组

boxList[0] 获取当前集合中的第一个LI（通过索引获取到具体的某一个LI即可）
boxList.length 获取集合中LI的数量

2.集合中的每一项存储的值又是一个元素对象(对象数组类型,包含很多的内置属性,例如id/className...)



boxList[1].style.color='red';修改集合中第二个li的文字颜色
```



### 函数 function
> 在JS当中,函数就是一个方法(一个功能体)基于函数一般是为了实现某个功能
```JavaScript
var total=10;
total+=10;
total=total/2;
total=total.toFixed(2);//=>保留小数点后边两位(数字由一个方法toFixed用来保留小数点后面的位数)


在后续代码中我们依然想实现相同的操作(加10除以2);我们需要重新编写代码
var total=10;
total+=10;
total=total/2;
total=total.toFixed(2);
console.log(total);

```
**函数诞生的目的就是为了实现封装**: 把实现一个功能的代码封装到一个函数中,后期想要实现这个功能,只需要把函数执行即可,不需要再次编写重复代码,起到了**低藕合高内聚(减少页面中的冗余代码,提高代码的重复使用率)**的作用

```JavaScript
function fn(){

var total=10;
total+=10;
total=total/2;
total=total.toFixed(2);
console.log(total);
}

fn();//=> 执行函数



ES3 标准中
function 函数名([参数]){

    函数体:实现功能的JS代码
}
//=>函数执行
函数名();




ES6标准中创建箭头函数:
let 函数名(变量名)=([参数])=>{
   
   函数体
}
函数名();

let fn=()=>{

    let total=10;

};
fn();
```

函数作为引用数据类型的一种,他也是按照引用地址来操作的,接下来我们学习一下函数的运行机制
> 1函数也是引用类型,首先会先开辟一个新的堆内存,把函数体中的代码当做"字符串"存储到内存中(对象向内存中存储的是键值对) 16进制地址
>2把开辟的堆内存的地址赋值给函数名(变量名)

此时我们输出fn(切记不是fn())代表的是当前函数本身;如果我们执行fn(),这是把函数执行
所以是否加小括号是两种不同本质的操作


[函数执行]
目的:把之前存储到堆内存中的代码字符串变为真正的JS代码自上而下执行,从而实现应有的功能.

1. 函数执行: 首先会形成一个私有的作用域(一个代码执行的环境,也是一个栈内存)提供JS执行赖以生存的环境;
2. 把之前在堆内存存储的字符串复制一份过来,变为真正的JS代码,在新开辟的作用域中自上而下执行

每次执行函数,形成的私有作用域是独立的,里面声明的变量(私有变量)也是独立的,互不影响互不冲突.

#### 函数中的参数function

> 参数是函数的入口:当我们在函数中封装一个功能,发现一些原材料不确定,需要执行的时候用户传递进来才可以,此时我们就基于参数的机制,提供出入口即可 我们把函数的入口称之为"形参变量"(入口即变量)
```JavaScript
//=> 此处的参数叫做形参:入口,形参是变量(n/m就是变量)
function sum(n,m){
=> n和m分别对应要求和的两个数字
var total=0;
total=n+m;
console.log(total);

}

//=>此处函数执行传递的值是实参:实参是具体的数据值
sum(10,20);  //=>n=10 m=20
sum(10); //=>n:10 m:undefined 设置了形参,执行时不传递值
sum(); //=>n和m都是undefined
sum(10,20,30); //=>n=10 m=20  30没有形参变量接收
```

