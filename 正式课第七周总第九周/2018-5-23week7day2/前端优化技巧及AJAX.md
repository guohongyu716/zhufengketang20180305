 [DOC]
### 前端性能优化

1.  在 JS 中尽量减少闭包的使用(原因:闭包会产生不释放的栈内存)
    A: 循环给元素做事件绑定时,尽可能把后期需要的的信息(例如索引)存到元素的自定义属性上,而不是创建闭包储存
    B: 可以在最外层形成一个闭包,把一些后续需要的公共信息进行储存,而不是每一个方法都创建闭包(例如单例模式)
    C: 尽可能手动释放不被占用的内存

2)  尽量合并 CSS 和 JS 文件(把需要引入的 css 合并为一个,JS 也合并为一个),原理是在减少 HTTP 请求次数,尽可能的把合并后的代码进行压缩,减小 HTTP 请求资源大小
    A:webpack 这种自动化构建工具,可以帮我们实现代码的合并和压缩(工程化开发)
    B:在移动开发(或者周追求高性能的 PC 端开发/[例如百度首页]),如果 CSS 或者 js 不是需要很多,我们可以选择把 CSS 和 JS 编程内嵌式(也就是吧代码直接写在 HTML 中)

3)  尽量使用字体图标或者 SVG 图标,来代替传统的 PNG 等格式图片(应为字体图标等是矢量图 (基于代码编写出来,)放大不会变形,而且渲染速度快,相比位图小一些)
4)  减少对 DOM 操作(主要是减少 DOM 的重绘和回流 (重拍))
    A: 关于重排的分离读写
    B: 使用文档碎片或者字符串拼接做数据绑定(DOM 的动态创建)
5)  在 JS 中避免"嵌套循环"(这种会额外增加很多循环次数)和死循环(一旦遇到死循环浏览器就卡科了)
6)  采用图片的懒加载(延迟加载)
    目的: 是为了减少页面 第一次加载过程中 HTTP 的请求次数,让页面加载更快

    步骤: 开始加载页面的时候，所有的真实图片都不去发送HTTP请求加载，而是给一张占位的背景图，当页面加载完，并且图片在可视区域内我们再去做图片加载

7)  利用浏览器和服务器端的缓存技术(304 缓存),把一些不经常跟新的静态资源文件做缓存处理(例如:JS,CSS,静态图片等都可以做缓存)
    原理也是为了减少 HTTP 请求大小, 让获取速度更快

8) 尽可能使用事件委托(事件代理)来处理事件绑定操作,减少DOM的频繁操作,其中包括给每一个DOm元素做事件绑定
9) 尽量较少CSS表达式使用 (expression)
    ```
  #myDiv {
    position: absolute;
    width: 100px;
    height: 100px;
    left: expression(document.body.offsetWidth - 110 + "px");
    top: expression(document.body.offsetHeight - 110 + "px");
    background: red;
  }
  ```


10)  CSS选择器的解析规则是从右向左解析 尽量减少标签选择器的使用
    ```css
    .container .link a{
    先找到所有的A，再筛选是在.link样式类中的，再次筛选是在.container样式类中的... 先找到的是所有的A，操作起来是消耗性能的，我们在使用CSS选择器的时候尽可能减少对标签选择器的使用
 }
```
11)  CSS雪碧图技术(CSS sprite/CSS 图片精灵)
    把所有相对较小资源图片汇总到一张大图上,后期我们只需要把大图加载下来,用背景定位方式展示对应的的小图即可
    ```css
    .bg{
    background:url('xxx.png');
  }
  .box1{
     background-position:xx xx;
  }
  .box2{
     background-position:xx xx;
  }

  <div class='bg box1'></div>
    ```
12) 减少对于cookie的使用,*(最主要的是减少本地COOKIE存储内容大小),应为客户操作COOKIE的时候,这些信息总是在客户端和服务端传来传去
13) 页面中的数据获取采用异步编程和延迟分批加载
        使用异步获取数据,是为了降低HTTP通道堵塞,不会因为数据没有请求回来耽误下面的信息的渲染,提高页面的打开速度(我们可以这样处理,需要动态绑定数据的区域先隐藏,等数据返回并且绑定完成后在让其显示)
        延迟分批加载类似于图片懒加载,是为了减少第一次页面加载时后的HTTP请求次数
14) 页面中出现音视频标签,我们不让页面加载的时候就去加载这些资源(要不然页面加载速度会变慢)(方案: 只需要设置 preload='none'即可) 等待页面加载完成,音视频播放的时候我们在加载音视频资源
15) 在客户端和服务器端进行信息交互的时候,对于多项数据我们尽可能基于JOSN格式来进行传送(JOSN格式的数据处理方便, 资源偏小) => 相对于XML格式的传输才会有这个优势
16) 尽可能是实现JS的封装,(低耦合高内聚),减少页面冗余代码(减少HTTP请求资源的大小)
17) CSS中设置定位后,最好使用Z-index改变盒子的层级,让所有的盒子不在同一平面上,这样后续处理的时候,性能有那么一点点提高
18) 在基于AJAX的get请求进行数据交互的时候,根据需求
19) 尽量减少对于filter滤镜的属性的使用(这个属性消耗性能较大)
20) 在CSS导入的时候尽量减少@import导入式,应为@import是同步操作,只有把这个对应的CSS导入,才会向下加载,而link是异步操作
21) 配置ETag(有点类似于304缓存)
22) 使用window.requestAnimationFrame(JS中的帧 动画)代替传统定时器动画
23) 减少递归使用,避免死递归,避免由于递归导致的栈内存嵌套(建议使用尾递归)
24) 避免使用iframe(不仅不好管控样式,而且相当于在A页面中加载了其他页面,消耗较大)
25) 利用H5中提供的localstorage本地缓存或者是manifest离线缓存,做一些信息的本地储存,下一次加载页面的时候直接从本地获取,减少HTTP请求次数
26) 基于SCRIPT 调取JS时候,可以使用defer或者async来异步加载


===额外技巧===
1.我们一般都把CSS放到BODY上，把JS放到BODY下面（原因：让其先加载CSS在加载JS，先加载CSS是为了保证页面渲染的过程中，元素是带着样式渲染的，而JS一般都是用来操作DOM元素的，需要等到元素加载完再操作）

2.能用CSS搞定的绝对不用JS，能用原生JS搞定的绝对不用插件，绝对不使用FLASH（除了音视频的低版本浏览器播放）
  =>CSS处理动画等功能的性能优于JS，而且CSS中的transform变形还开起了硬件加速

3.JS中尽量减少对EVAL的使用，因为JS合并压缩的时候，可能出现由于符号不完善，导致的代码执行优先级错乱问题，EVAL处理起来消耗的性能也是偏大一点的

4.使用keep-alive实现客户端和服务器端的长连接

5.尽量使用设计模式来管理我们的代码（单例、构造、Promise、发布订阅），方便后期的升级和维护

6.开启服务器端的gzip压缩（这个压缩可以有效减少请求资源文件的大小），其实客户端的图片等资源也是可以进行压缩的（但是对于24位的位图，压缩后可能会变模糊）

7.页面中不要出现无效的链接（利于SEO优化），还有其它技巧：提高关键字曝光率、img需要加alt、设置meta标签、标签语义化...

8.避免使用with语句（非常耗性能）


**重量级优化: 做CDN加速(烧钱机器)**


### AJAX 
#### 1.async javascript and xml 异步的JS和XML
    在AJAX中的异步不是我们理解的同步异步编程,而是泛指"局部刷新",但是我们在以后的AJAX请求中尽可能使用异步获取数据(应为异步获取数据不会阻塞下面代码执行)

    xml 是一种文件格式,(我们可以吧HTML理解为XML的一种)可扩展的标记语言,他的作用是用自己扩展的一些语义标签来存储一些数据和内容,这样存储的好处是清晰的展示出数据的结构

    很久以前,AJAX刚刚兴起的时候,客户端从服务器端获取数据,服务器为了清析的表单数据结构,都是返回XML格式的内容,当下,我们获取数据一般都是JOSN格式的内容,JOSN相对于XML来说,也能清晰的表达数据结构,而且访问里面数据时后操作起来比XML更加简便(但是现在某些项目中,服务器返回给客户端的数据不单纯是数据,而是数据和需要展示的结构拼接好的得结果(类似于我们自己的字符串拼接)换句话说,是服务器端把数据和结构拼接好返回给我们,此时我们返回数据格式一般都是XML格式字符串)


全局刷新: 页面是服务器端渲染的,[前端后端不分离项目]
服务器端渲染的好处(Java)




很好大网网站首页内容都是基于服务器端


局部刷新: AJAX诞生就是为了实现局部刷新
1.基于AJAX向服务器发送请求获取数据(不管是JOSN换是服务器渲染好的XML文档)都是前后端分离项目
A: 不利于SEO优化(源代码中看不到动态增加的数据)
B: 都可以实现局部刷新
    例如京东: 首屏数据是基于AJAX从服务器端获取的XML字符串(服务器端渲染),其他屏数据是从服务器获取JOSN,客户端拼接字符串掺入到指定的区域中(客户端渲染)

2.不基于AJAX.直接通过浏览器向服务器发送请求,服务器把需要呈现的内容返回,这种模式是非前后端分离项目
A: 有利于SEO优化
B: 只能实现全局刷新
C: 请求页面的后缀名一般不是,html 而是PHP/.jsp/.aspx/.asp... 也有.html 这个是基于node做后台



#### 2 AJAX操作
```
//=>创建AJAX实例：IE6中是不兼容的，使用的是new ActiveXObject来实现的
let xhr = new XMLHttpRequest();

//=>打开请求：发送请求之前的一些配置项
//1.HTTP METHOD 请求方式
// GET/DELETE/HEAD/OPTIONS/TRACE/CONNECT
// POST/PUT
//2.URL 向服务器端发送请求的API（Application Programming Interface）接口地址
//3.ASYNC 设置AJAX请求的同步异步，默认是异步（写TRUE也是异步），FALSE是同步，项目中都使用异步编程，防止阻塞后续代码执行
//4.USER-NAME/USER-PASS：用户名密码，一般不用
xhr.open([HTTP METHOD],[URL],[ASYNC],[USER-NAME],[USER-PASS]);

//=>3.事件监听：一般监听的都是 READY-STATE-CHANGE 事件（AJAX状态改变事件），基于这个事件可以获取服务器返回的响应头响应主体内容
xhr.onreadystatechange=()=>{
    if(xhr.readyState===4 && xhr.status===200){
       xhr.responseText;
    }
};

//=>4.发送AJAX请求：从这步开始，当前AJAX任务开始，如果AJAX是同步的，后续代码不会执行，要等到AJAX状态成功后在执行，反之异步不会
xhr.send([请求主体内容]);
```



#### 3. 关于HTTP请求方式的一点学习
> 所有的请求都可以给服务端传递内容,也可以从服务器端获取内容
GET: 从服务器端获取数据
poST: 向服务器端推送数据(给的多拿得少)
DELETE: 删除服务器端的某些内容(一般是删除一些文件)
PUT:   向服务器端上存放一些内容(一般也是存放文件)
HEAD: 只想获取服务器返回的响应头信息,不要响应主体的内容
OPTIONS: 一般使用他向服务器发送一个探测性请求,如果服务器端返回的信息了,说明当前客户端和服务器端建立了链接.我们可以继续执行其他请求了(TRACE是干这件事的,但是axios这个AJAX类库再基于cross donain 进行跨域请求的时候,就是先发送OPTIONS请求进行探测尝试,如果能联通服务器,才会继续发生其他的请求)

GET 和 POST
[传递给服务器信息的方式不一样]
GET是基于URL地址"问号传参"的方式把信息传递给服务器,POST是基于"请求主体"把信息传递给服务器


GET一般用于拿(给服务器的会少些),而POST给服务器的很多,如果POST是基于问号传参方式来搞会出现一些问题: URL 会拼接很长,浏览器对于URL的长度有最大限度(谷歌:8kb 火狐7KB  IE: 2KB),超时部分浏览器会把它截掉=> 所以GET请求可以基于URL传参,而POST都是使用请求主体传递(请求主体理论上是没有限制的,但是真实项目中我们会自己做大小限制,防止上传过大信息导致请求迟迟完不成)


[GET不安全,POST相对安全]
应为GET是基于"问号传参"把信息传递给服务器,容易被骇客进行NRL劫持, POST是基于请求主体传递的,相对来说不好被劫持,所以登录,注册设计安全性的交互操作,我们都应该用POST请求.

[GET会产生不可控的缓存,POST不会]
不可控: 不是想要就要,不想要就不要的,这是浏览器自主记忆的缓存,我们无法给予JS控制,真实项目中我们会把这个缓存干掉
GET 请求产生缓存的原因: 连续多次向相同的地址(并且传递的参数信息也是相同的)发送请求,浏览器会把之前获取的数据从缓存中拿到返回,导致无法获取服务器最新的数据(POST不会)



#### AJAX状态
0=> UNSENT  刚开始创建XHR 还没有发送
1=> OPENED   已经执行了OPEN这个操作
2=> HEADERS RECEIVED 已经发送AJAX请求 (AJAX任务开始),响应头信息已被客户端接受了(响应头包含了: 服务器的时间,返回的HTTP状态码)
3=> LOADING 响应主体内容正在返回
4=> DONE 响应主体内容已被客户端接收



#### HTTP 网络状态码(STATUS)
根据状态码能够清楚的反应出当前交互的结果及原因

    200  OK 成功 (只能证明服务器成功返回信息了，但是信息不一定是你业务需要的)


    301 Moved Permanently 永久转移 (永久重定向 => 307)
        => 域名更改,访问原始域名重定向到新的域名

    302 Move temporarily  临时转移 (临时重定向=> 307)
        => 网站现在是基于HTTPS协议运作的,如果访问的是HTTP协议,会基于307 重定向到HTTps 协议上

        => 302一般作用做服务器负载均衡: 当一台服务器达到最大并发数的时候,会把后续访问的用户临时转移到其他的服务器机组上处理 

        =>偶尔真实项目中会把所有的图片放到单独的服务器上“图片处理服务器”，这样减少主服务器的压力，当用户向主服务器访问图片的时候，主服务器都把它转移到图片服务器上处理

    304 Not Modified 设置缓存
        => 对于不经常更新的资源文件，例如：CSS/JS/HTML/IMG等，服务器会结合客户端设置304缓存，第一次加载过这些资源就缓存到客户端了，下次再获取的时候，是从缓存中获取；如果资源更新了，服务器端会通过最后修改时间来强制让客户端从服务器重新拉取；基于CTRL+F5强制刷新页面，304做的缓存就没有用了。
    
    400 Bad Request 请求参数错误
    401 Unauthorized 无权限访问
    404 Not Found  找不到资源(地址不存在)
    413 Request Entity Too Large 和服务器交互的内容资源超过服务器最大限制

    500 Internal Server Error 未知的服务器错误
    503 Service Unavailable 服务器超负荷


#### 关于XHR的属性和方法

 xhr.response  响应主体内容
  xhr.responseText 响应主体的内容是字符串（JSON或者XML格式字符串都可以）
  xhr.responseXML 响应主体的内容是XML文档

  xhr.status 返回的HTTP状态码
  xhr.statusText 状态码的描述

  xhr.timeout 设置请求超时的时间
  xhr.withCredentials 是否允许跨域（FALSE）

  xhr.abort() 强制中断AJAX请求
  xhr.getAllResponseHeaders() 获取所有响应头信息
  xhr.getResponseHeader([key]) 获取KEY对应的响应头信息，例如：xhr.getResponseHeader('date')就是在获取响应有中的服务器时间

  xhr.open() 打开URL请求
  xhr.overrideMimeType() 重写MIME类型
  xhr.send() 发送AJAX请求
  xhr.setRequestHeader() 设置请求头